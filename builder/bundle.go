// Copyright 2018 The Serulian Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package builder

import (
	"github.com/serulian/compiler/bundle"
	"github.com/serulian/compiler/generator/es5"
	"github.com/serulian/compiler/graphs/scopegraph"
	"github.com/serulian/compiler/integration"
	"github.com/serulian/compiler/sourcemap"
)

// SourceAndBundle holds the built ECMAScript source, its source map, and any bundled files.
type SourceAndBundle struct {
	// bundledFiles holds the files generated by the various language integrations.
	bundledFiles bundle.Bundle

	// source is the generated ECMAScript source.
	source string

	// sourceMap holds the source map for the generated source.
	sourceMap *sourcemap.SourceMap
}

// GenerateSourceAndBundle generates the full ECMAScript source for the given scope result, as well as its
// sourcemap, and any additional bundled files produced by language integrations.
func GenerateSourceAndBundle(scopeResult scopegraph.Result) SourceAndBundle {
	if !scopeResult.Status {
		panic("GenerateSourceAndBundle given an invalid scope result.")
	}

	// Generate the source and its map.
	generated, sourceMap, err := es5.GenerateES5(scopeResult.Graph)
	if err != nil {
		panic(err)
	}

	bundler := bundle.NewBundler()

	// Have the language integrations add any additional files necessary to the bundle.
	for _, langIntegration := range scopeResult.LanguageIntegrations {
		bundlerIntegration, isBundler := langIntegration.(integration.BundlerIntegration)
		if !isBundler {
			continue
		}

		bundlerIntegration.PopulateFilesToBundle(bundler)
	}

	return SourceAndBundle{
		bundledFiles: bundler.Freeze(bundle.InMemoryBundle),
		source:       generated,
		sourceMap:    sourceMap,
	}
}

// Source returns the ECMAScript source generated.
func (sab SourceAndBundle) Source() string {
	return sab.source
}

// SourceMap returns the source map filled for the generated source.
func (sab SourceAndBundle) SourceMap() *sourcemap.SourceMap {
	return sab.sourceMap
}

// BundledFiles returns all files bundled by the lang integrations. Note that these do *not* include
// the generated source or map.
func (sab SourceAndBundle) BundledFiles() bundle.Bundle {
	return sab.bundledFiles
}

// BundleWithSource returns all files bundled by the generator run, *including* the source file and its source map.
func (sab SourceAndBundle) BundleWithSource(generatedSourceFileName string, sourceRoot string) bundle.Bundle {
	builtMap := sab.sourceMap.Build(generatedSourceFileName, sourceRoot)
	sourceMapBytes, err := builtMap.Marshal()
	if err != nil {
		panic(err)
	}

	mapname := generatedSourceFileName + ".map"
	generated := sab.source + "\n//# sourceMappingURL=" + mapname

	fullBundle := sab.bundledFiles
	fullBundle = bundle.WithFile(fullBundle, bundle.FileFromString(generatedSourceFileName, bundle.Script, generated))
	fullBundle = bundle.WithFile(fullBundle, bundle.FileFromBytes(mapname, bundle.Resource, sourceMapBytes))
	return fullBundle
}
