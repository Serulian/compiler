from webidl`basic` import Number
from webidl`basic` import String as NativeString
from webidl`basic` import Boolean as NativeBoolean

@•typealias('tuple')
class Tuple<T, Q> {
	var<T?> First = null
	var<Q?> Second = null

	constructor Build(first T, second Q) {
		var tuple = Tuple<T, Q>.new()
		tuple.First = first
		tuple.Second = second
		return tuple
	}
}


@•typealias('stringable')
interface Stringable {
	function<string> String()
}

@•typealias('stream')
interface Stream<T> {
	function<Tuple<T, bool>> Next()
}

@•typealias('streamable')
interface Streamable<T> {
	function<Stream<T>> Stream()
}

@•typealias('error')
interface Error {
	property<string> Message { get }
}

@•typealias('promise')
interface Promise<T> {
	function<Promise<T>> Then(callback function<void>(T))
	function<Promise<T>> Catch(callback function<void>(error))
}

@•typealias('releasable')
interface Releasable {
	function<void> Release()
}

@•typealias('function')
class Function<T> {}

class FakeIntStream {
	function<Tuple<int, bool>> Next() {
	  return Tuple<int, bool>.Build(2, true)
	}
}

@•typealias('int')
type Integer : Number {
	operator Range(start int, end int) {
		return FakeIntStream.new()
	}

	operator Compare(left int, right int) {
		return Integer(Number(left) - Number(right))
	}

	operator Equals(left int, right int) {
		return Boolean(Number(left) == Number(right))
	}

	operator Plus(left int, right int) {
		return Integer(Number(left) + Number(right))
	}

	function<void> Release() {}
}

@•typealias('bool')
type Boolean : NativeBoolean {
	operator Compare(left bool, right bool) {
		if left == right {
			return 0
		}

		return -1
	}

	operator Equals(left bool, right bool) {
		return NativeBoolean(left) == NativeBoolean(right)
	}
}

@•typealias('float64')
class Float64 {}

@•typealias('string')
type String : NativeString {
	function<string> String() {
		return ''
	}
}

@•typealias('list')
class List<T> {}

@•typealias('map')
class Map<T, Q> {}