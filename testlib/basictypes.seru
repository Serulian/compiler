from webidl`basic` import Number
from webidl`basic` import String as NativeString
from webidl`basic` import Boolean as NativeBoolean
from webidl`basic` import Array
from webidl`basic` import Object
from webidl`basic` import debugprint

@•typealias('tuple')
class Tuple<T, Q> {
	var<T?> First = null
	var<Q?> Second = null

	constructor Build(first T, second Q) {
		var tuple = Tuple<T, Q>.new()
		tuple.First = first
		tuple.Second = second
		return tuple
	}
}

@•typealias('slice')
class Slice<T> {}

@•typealias('stringable')
interface Stringable {
	function<string> String()
}

@•typealias('stream')
interface Stream<T> {
	function<Tuple<T, bool>> Next()
}

@•typealias('streamable')
interface Streamable<T> {
	function<Stream<T>> Stream()
}

@•typealias('error')
interface Error {
	property<string> Message { get }
}

@•typealias('promise')
interface Promise<T> {
	function<Promise<T>> Then(callback function<void>(T))
	function<Promise<T>> Catch(callback function<void>(error))
}

@•typealias('releasable')
interface Releasable {
	function<void> Release()
}

@•typealias('function')
class Function<T> {}

class IntStream {
	var<int> start = 0
	var<int> end = -1
	var<int> current = 0

	constructor OverRange(start int, end int) {
		var s = IntStream.new()
		s.start = start
		s.end = end
		s.current = start
		return s
	}

	function<Tuple<int, bool>> Next() {
		if this.current <= this.end {
			var t = Tuple<int, bool>.Build(this.current, true)
			this.current = this.current + 1
			return t
		}

		return Tuple<int, bool>.Build(this.current, false)
	}
}

@•typealias('int')
type Integer : Number {
	operator Range(start int, end int) {
		return IntStream.OverRange(start, end)
	}

	operator Compare(left int, right int) {
		return Integer(Number(left) - Number(right))
	}

	operator Equals(left int, right int) {
		return Boolean(Number(left) == Number(right))
	}

	operator Plus(left int, right int) {
		return Integer(Number(left) + Number(right))
	}

	operator Minus(left int, right int) {
		return Integer(Number(left) - Number(right))
	}

	function<void> Release() {}

	property<Stringable> MapKey {
		get { return this }
	}

	function<string> String() {
		return String(Number(this).toString())
	}
}

@•typealias('bool')
type Boolean : NativeBoolean {
	operator Compare(left bool, right bool) {
		if left == right {
			return 0
		}

		return -1
	}

	operator Equals(left bool, right bool) {
		return NativeBoolean(left) == NativeBoolean(right)
	}

	function<string> String() {
		return String(NativeBoolean(this).toString())
	}

	property<Stringable> MapKey {
		get { return this }
	}
}

@•typealias('float64')
class Float64 {}

@•typealias('string')
type String : NativeString {
	function<string> String() {
		return this
	}

	property<Stringable> MapKey {
		get { return this }
	}
}

@•typealias('mappable')
interface Mappable {
	property<Stringable> MapKey { get }
}

@•typealias('list')
class List<T> {
	var<Array> items = Array.new()
	
	constructor forArray(arr Array) {
		var l = List<T>.new()
		l.items = arr
		return l
	}

	property<int> Count {
		get {
			return int(this.items.length)
		}
	}
}

@•typealias('map')
class Map<T : Mappable, Q> {
	var<Object> internalObject = Object.new()

	constructor forArrays(keys Array, values Array) {
		var map = Map<T, Q>.new()
		var len = int(keys.length)
		for i in 0..(len - 1) {
			var tKey = keys[Number(i)].(T)
			map[tKey] = values[Number(i)].(Q)
		}
		return map
	}

	operator<Q?> Index(key T) {
		var keyString = key.MapKey.String()
		var value = this.internalObject[NativeString(keyString)]
		if value is null {
			return null
		}

		return value.(Q)
	}

	operator SetIndex(key T, value Q) {
		var keyString = key.MapKey.String()
		this.internalObject[NativeString(keyString)] = value
	}
}