from webidl`basic` import Number
from webidl`basic` import String as NativeString
from webidl`basic` import Boolean as NativeBoolean
from webidl`basic` import Array
from webidl`basic` import Object
from webidl`basic` import Error as NativeError
from webidl`basic` import debugprint
from webidl`basic` import JSON as NativeJSON
from webidl`basic` import __serulian_internal as Internal

function<string> formatTemplateString(pieces []string, values []stringable) {
	var result = ''
	for i in 0 .. (pieces.Length - 1) {
		result = result + pieces[i]
		if i < values.Length {
			result = result + values[i].String()
		}
	}
	return result
}

function<Q*> MapStream<T, Q>(stream T*, mapper function<Q>(T)) {
	for item in stream {
		yield mapper(item)
	}
}

@•typealias('tuple')
class Tuple<T, Q> {
	var<T?> First = null
	var<Q?> Second = null

	constructor Build(first T, second Q) {
		var tuple = Tuple<T, Q>.new()
		tuple.First = first
		tuple.Second = second
		return tuple
	}
}

@•typealias('mapping')
type Mapping<T> : Object {
	constructor Empty() {
	    return Mapping<T>(Object.new())
	}

	constructor overObject(obj Object) {
		return Mapping<T>(obj)
	}

	property<[]string> Keys {
		get {
			return Slice<string>.overArray(Object.keys(Object(this)))
		}
	}

	operator<T?> Index(key string) {
		var value = Object(this)[NativeString(key)]
		if value is null {
			return null
		}

		return value.(T)
	}	
}

@•typealias('slice')
type Slice<T> : Array {
	constructor Empty() {
		return Slice<T>(Array.new())
	}

	constructor overArray(arr Array) {
		return Slice<T>(arr)
	}

	operator<T> Index(index int) {
		return Array(this)[Number(index)].(T)
	}

	operator<Slice<T>> Slice(startindex int?, endindex int?) {
		var start = startindex ?? 0
		var end = endindex ?? this.Length

		if start < 0 {
			start = start + this.Length
		}

		if end < 0 {
			end = end + this.Length
		}

		if start >= end {
			return Slice<T>.Empty()
		}

		return Slice<T>.overArray(Array(this).slice(Number(start), Number(end)))
	}

	property<int> Length {
		get {
			return int(Array(this).length)
		}
	}
}

@•typealias('stringable')
interface Stringable {
	function<string> String()
}

@•typealias('stream')
interface Stream<T> {
	function<Tuple<T, bool>> Next()
}

@•typealias('streamable')
interface Streamable<T> {
	function<Stream<T>> Stream()
}

@•typealias('error')
interface Error {
	property<string> Message { get }
}

@•typealias('awaitable')
interface Awaitable<T> {
	function<Awaitable<T>> Then(callback function<void>(T))
	function<Awaitable<T>> Catch(callback function<void>(error))
}

@•typealias('releasable')
interface Releasable {
	function<void> Release()
}

@•typealias('function')
class Function<T> {}

@•typealias('$intstream')
class IntStream {
	var<int> start = 0
	var<int> end = -1
	var<int> current = 0

	constructor OverRange(start int, end int) {
		var s = IntStream.new()
		s.start = start
		s.end = end
		s.current = start
		return s
	}

	function<Tuple<int, bool>> Next() {
		if this.current <= this.end {
			var t = Tuple<int, bool>.Build(this.current, true)
			this.current = this.current + 1
			return t
		}

		return Tuple<int, bool>.Build(this.current, false)
	}
}

@•typealias('int')
type Integer : Number {
	operator Range(start int, end int) {
		return IntStream.OverRange(start, end)
	}

	operator Compare(left int, right int) {
		return Integer(Number(left) - Number(right))
	}

	operator Equals(left int, right int) {
		return Boolean(Number(left) == Number(right))
	}

	operator Plus(left int, right int) {
		return Integer(Number(left) + Number(right))
	}

	operator Minus(left int, right int) {
		return Integer(Number(left) - Number(right))
	}

	function<void> Release() {}

	property<Stringable> MapKey {
		get { return this }
	}

	function<string> String() {
		return String(Number(this).toString())
	}
}

@•typealias('bool')
type Boolean : NativeBoolean {
	operator Compare(left bool, right bool) {
		if left == right {
			return 0
		}

		return -1
	}

	operator Equals(left bool, right bool) {
		return Boolean(NativeBoolean(left) == NativeBoolean(right))
	}

	function<string> String() {
		return String(NativeBoolean(this).toString())
	}

	property<Stringable> MapKey {
		get { return this }
	}
}

@•typealias('float64')
class Float64 {}

@•typealias('string')
type String : NativeString {
	function<string> String() {
		return this
	}

	operator Equals(first string, second string) {
		return Boolean(NativeString(first) == NativeString(second))
	}

	operator Plus(first string, second string) {
		return String(NativeString(first) + NativeString(second))
	}

	property<Stringable> MapKey {
		get { return this }
	}

	property<int> Length {
		get {
			return Integer(NativeString(this).length)
		}
	}
}

@•typealias('mappable')
interface Mappable {
	property<Stringable> MapKey { get }
}

@•typealias('list')
class List<T> {
	var<Array> items = Array.new()
	
	constructor forArray(arr Array) {
		var l = List<T>.new()
		l.items = arr
		return l
	}

	property<int> Count {
		get {
			return int(this.items.length)
		}
	}

	operator<T> Index(index int) {
		return this.items[&index].(T)
	}

	operator<Slice<T>> Slice(startindex int?, endindex int?) {
		var start = startindex ?? 0
		var end = endindex ?? this.Count

		if start < 0 {
			start = start + this.Count
		}

		if end < 0 {
			end = end + this.Count
		}

		if start >= end {
			return Slice<T>.Empty()
		}

		return Slice<T>.overArray(this.items.slice(Number(start), Number(end)))
	}
}

@•typealias('map')
class Map<T : Mappable, Q> {
	var<Object> internalObject = Object.new()

	constructor forArrays(keys Array, values Array) {
		var map = Map<T, Q>.new()
		var len = int(keys.length)
		for i in 0..(len - 1) {
			var tKey = keys[Number(i)].(T)
			map[tKey] = values[Number(i)].(Q)
		}
		return map
	}

	function<Mapping<Q>> Mapping() {
		return Mapping<Q>(this.internalObject)
	}

	operator<Q?> Index(key T) {
		var keyString = key.MapKey.String()
		var value = this.internalObject[NativeString(keyString)]
		if value is null {
			return null
		}

		return value.(Q)
	}

	operator SetIndex(key T, value Q) {
		var keyString = key.MapKey.String()
		this.internalObject[NativeString(keyString)] = value
	}
}

@•typealias('json')
class JSON {
	constructor Get() {
		return JSON.new()
	}

	function<string> Stringify(value mapping<any>) {
		return string(NativeJSON.stringify(Object(value), Internal.autoUnbox))
	}

	function<mapping<any>> Parse(value string) {
		return mapping<any>(NativeJSON.parse(NativeString(value), Internal.autoBox))
	}
}

@•typealias('$stringifier')
interface Stringifier {
	constructor Get() {
		return JSON.new()
	}

	function<string> Stringify(value mapping<any>)
}

@•typealias('$parser')
interface Parser {
	constructor Get() {
		return JSON.new()
	}

	function<mapping<any>> Parse(value string)
}

@•typealias('wrappederror')
type WrappedError : NativeError {
	constructor For(err NativeError) {
		return WrappedError(err)
	}

	property<string> Message {
		get {
			return string(NativeError(this).message)
		}
	}
}
