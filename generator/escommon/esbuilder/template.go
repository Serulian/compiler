// Copyright 2016 The Serulian Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package esbuilder

import (
	"bytes"
	"text/template"

	"github.com/serulian/compiler/sourcemap"
)

// TemplateSourceBuilder defines an interface for a templated code block.
type TemplateSourceBuilder interface {
	// WithMapping adds a source mapping to the block being built.
	WithMapping(mapping sourcemap.SourceMapping) SourceBuilder

	// AsExpression returns the template as an expression.
	AsExpression() ExpressionBuilder

	// mapping returns the source mapping for the block being built.
	mapping() (sourcemap.SourceMapping, bool)

	emitSource(sb *sourceBuilder)
}

// templateBuilder defines a wrapper for templates.
type templateBuilder struct {
	name           string
	templateSource string
	data           interface{}

	// The source mapping for the template as a whole, if any.
	sourceMapping *sourcemap.SourceMapping
}

// offsetedSourceMap represents a source map offseted by some index
// into the string generated by the template.
type offsetedSourceMap struct {
	// The 0-based offset into the templated string.
	offset int

	// The source map at the offset.
	sourcemap *sourcemap.SourceMap
}

// WithMapping adds a source mapping to a builder.
func (builder templateBuilder) WithMapping(mapping sourcemap.SourceMapping) SourceBuilder {
	builder.sourceMapping = &mapping
	return builder
}

// AsExpression returns the template as an expression.
func (builder templateBuilder) AsExpression() ExpressionBuilder {
	return expressionBuilder{wrappedTemplateNode{builder}, nil}
}

func (builder templateBuilder) mapping() (sourcemap.SourceMapping, bool) {
	if builder.sourceMapping == nil {
		return sourcemap.SourceMapping{}, false
	}

	return *builder.sourceMapping, true
}

func (builder templateBuilder) emitSource(sb *sourceBuilder) {
	var maps = make([]offsetedSourceMap, 0)
	var source bytes.Buffer

	// Register an `emit` function which does two things:
	//
	// 1) Builds and emits the source for the node at the place the function is called
	// 2) Saves the node's source map at the current template location for later appending
	emitNode := func(node SourceBuilder) string {
		if node == nil {
			return ""
		}

		if sb.sourcemap != nil {
			currentIndex := source.Len()
			sm := sourcemap.NewSourceMap()
			buf := BuildSourceAndMap(node, sm)
			maps = append(maps, offsetedSourceMap{currentIndex, sm})
			return buf.String()
		}

		buf := BuildSource(node)
		return buf.String()
	}

	funcMap := template.FuncMap{
		"emit": emitNode,
	}

	t := template.New(builder.name).Funcs(funcMap)
	parsed, err := t.Parse(builder.templateSource)
	if err != nil {
		panic(err)
	}

	// Execute the template.
	eerr := parsed.Execute(&source, builder.data)
	if eerr != nil {
		panic(eerr)
	}

	// Append the generated source to the builder.
	generatedSource := source.String()
	sb.append(generatedSource)

	// Append any offsetted source mappings.
	if sb.sourcemap != nil {
		for _, osm := range maps {
			sb.sourcemap.AppendMap(osm.sourcemap.OffsetBy(generatedSource[0:osm.offset]))
		}
	}
}

// Template returns an inline templated code block.
func Template(name string, template string, data interface{}) TemplateSourceBuilder {
	return templateBuilder{name, template, data, nil}
}
